## Lecture 4
### **Problem 1** 
The traditional interval problem. 

We can use $OPT(j)$ to represent the optimal arrangement of works in the scope of ${1,2,\dots,n}$, then $OPT(j)=\max\{v_j+OPT(P(j)), OPT(j-1)\}$, where $P(j)$ represents the max index $k$ such that the ending time of $I_k$ is earlier than the beginning time of $I_j$.

### **Problem 2** 
Find the best approximation of given $n$ points with segments, i.e., split the $n$ given points into $k$ continuous fractions, and use $k$ segments to approximate each fraction. Our goal is to minimize $Ck+\sum_{i=1}^{k}error(\text{segment}_i)$. 

*The algorithm*: In fact, you can use $OPT(j)$ to represent the best approximate error of the first $j$ points, then $OPT(j)=\max_{1\le k\le j}\{OPT(k-1)+C+error(k,j)\}$, where $error(k,j)$ represents the best approximate error of points $k,\dots,j$ with one segment which can be calculated directly.

**Projective clustering** is another problem that might be worthy to study.
Â  
### **Problem 3** Subset sum & knapsack

**Subset sum:** given a set $A$ consisting of $n$ items with their weights $w_i$. Input a value $W$, and figure out whether there exists a subset of $A$ whose total weight of its items is $W$.

**Knapsack:** Additionally, each item has a value, our goal is to ensure that the total weight of a subset is less or equal to $W$ and maximize the total value of this subset.

- In fact, the running time can be $poly(n,W)$ when $w_i$'s are non-negative integers. However, without the assumption, they are NP-Complete and NP-Hard because the input scale is actually $O(n\log W)$. The running time of the following algorithm is pseudo-polynomial time.

- *The algorithm* uses $OPT(j,W)$ to represent the optimal solution for capacity $W$ with items with index less or equal to $j$, then $OPT(j,W)=\max \{OPT(j-1,W), OPT(j-1,W-w_j)+v_j\}$.

### **Problem 4** Shortest path with possibly negative edge weights without negative cycles.

*Bellman-Ford Algorithm*'s method is DP. A natural method is to use $OPT(v, i)$ to represent the shortest path from $v$ to $t$ with less or equal to $i$ edges. In fact, $OPT(v,i)=\min\{\min _{v\rightarrow u}\{C_{vu}+OPT(u,i-1)\}, OPT(v,i-1)\}$.

- *Algorithm analysis* The time complexity is $O(nm)$ and the space complexity is $O(n)$.

The real *Bellman-Ford Algorithm* is more elegant. We can use $M[v]$ to denote the shortest path from $v$ to $t$, then we can use $M[v]=\min \{M[v],\min _{v\rightarrow u}\{C_{vu}+M[u]\}\}$. After $i$ iterations, $M[v]$ is in fact less or equal to $OPT(v, i)$.

### **Problem 4'** 
Additionally, we not only need to output the length of the shortest path but also need to output the shortest path itself.

Maintain an array $First[u]$ to be the first vertex after $u$ on the recent shortest path from $u$ to $t$. Whenever we update $M[u]$ with $C_{uv}+M[v]$, let $First[u]$ be $v$.

*Proof*: Let $P$ be the pointer graph generated by $First[u]$, then it's easy to illustrate that if there is a cycle in $P$ at any stage, then the total cost of this cycle must be negative. 
