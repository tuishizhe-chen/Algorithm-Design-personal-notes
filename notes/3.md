# Lecture 3

## Dijkstra Algorithm

**Goal: to output the shortest road from $v$ to arbitrary vertex $u$.**

The algorithm is: maintain a set $A$ contains vertices that have been detected. Use $d(u)$ to record recent shortest road from $v$ to it. In each iteration, select a vertex $w$ from $V-A$ which has minimum $d(w)$ and push it into $A$, and then $\forall w\rightarrow x$, let $d(x)$ be $\max\{d(x),d(w)+(w\rightarrow x)\}$.

**Proof:** Let $v_1,\dots,v_n$ be the inserting sequence. It's obvious that $d(v_i)$ records the minimum cost from $v$ to $v_i$ via vertices with index less than $k$. let $v_k$ be the one with the minimum index such that the shortest road from $v$ to it has length less than $d(v_k)$, then this shorter road must contains at least 1 vertex with index greater than $k$. In the other hand, because $d(v_1)\le d(v_2)\le d(v_3)\le\dots\le d(v_n)$ and for arbitrary $i$, $d(v_i)$ is getting less and less, so the real shortest road from $v$ to $v_k$ can't contain vertices with index greater than $k$.

## Prim Algorithm

**Goal: To output MST**

The algorithm maintain a set $A$, initial it with a unique vertex. In each iteration, push the vertex with shortest edge to $A$ into $A$.

**Proof:** Similar with Kruskal's algorithm.

**Algorithm Analyze:** For any vertex inserting process, it cost $O(d \cdot \log n)$ times to maintain the heap contains minimum distance from vertices to $A$, where $d$ represents the degree of the inserting vertex. Therefore, the algorithm cost $O(m \log n)$ to with applying heap.

## Kruskal's Algorithm

**Goal: To output MST**

The algorithm use greedy method, sorting all edges with increasing weights and push them into $F$ one by one, skip the edges who generate a cycle after inserting.

**Proof:** Proof that the edge set $E_k$, which is the set contains the first $k$ edges been inserted, satisfied that there exists a MST $T_k$ contains all the edges in $E_k$ by induction on $k$. $k\rightarrow k+1$, on the unique cycle in $T_k+e_{k+1}$, select an edge that is not in $T_k$ and delete it, then $T_k$ becomes a tree with sum of weights less than $T_k$, which contradicts with the fact that $T_k$ is a MST.

**Algorithm Analyze:** The sorting cost $O(m \log m)$ applying heap sort, and after that use DSU to maintain a forest to find out whether two vertices is in a component with $O(1)$ time. The algorithm cost $O(m \log m)$ time.

## Huffman Codes

**Goal:** Given $n$ weights, need to give $n$ 0-1 codes to minimize $\sum_{i=1}^{n}\text{length}(c_i)w_i$.

The algorithm is in each iteration, select two nodes with least weights and let them be brothers in the tree.

## Priority Queue and Heap

You can use Fibonacci heap to optimize Prim or Dijkstra algorithm.